# Wikimedia VCL file for <%= fqdn %>, site <%= site %>
# This file is managed by Puppet!

# GeoIP
# declare the function signature
# so we can use them
C{
	#include <string.h>
	double TIM_real(void);
	void TIM_format(double t, char *p);
}C

# init GeoIP code
C{
	#include <dlfcn.h>
	#include <stdlib.h>
	#include <stdio.h>
	#include <string.h>
	#include <GeoIPCity.h>
	#include <pthread.h>
	#include <sys/types.h>
	#include <sys/socket.h>
	#include <netdb.h>
	#include <arpa/inet.h>

	pthread_mutex_t geoip_mutex = PTHREAD_MUTEX_INITIALIZER;

	GeoIP *gi;
	void geo_init () {
		if (!gi) {
			gi = GeoIP_open("/usr/share/GeoIP/GeoIPCity.dat", GEOIP_MEMORY_CACHE);
		}
	}
	getaddrfamily(const char *addr) {
		struct addrinfo hint, *info=0;
		memset(&hint, 0, sizeof(hint));
		hint.ai_family = AF_UNSPEC;
		hint.ai_flags = AI_NUMERICHOST;
		int ret = getaddrinfo(addr, 0, &hint, &info);
		if (ret) {
			freeaddrinfo(info);
			return -1;
		}
		int result = info->ai_family;
		freeaddrinfo(info);
		return result;
	}
}C

# Hosts we trust for XFF
acl allow_xff {
<% varnish_xff_sources.each do |source| -%>
	"<%= source["ip"] %>"/<%= source["mask"] %>;
<% end -%>
}

# Backends

# List of Puppet generated backends
<% varnish_backends.each do |backend| -%>
backend <%= backend.split(".")[0] %> {
	.host = "<%= backend %>";
	.max_connections = 100;
	.connect_timeout = 3s;
	.first_byte_timeout = 10s;
	.between_bytes_timeout = 2s;
	.probe = {
		.request =
			"GET /w/load.php HTTP/1.1"
			"Host: en.wikipedia.org"
			"User-agent: Varnish backend check"
			"Connection: close";
                .timeout = 5s;
	}
}

<% end -%>

# Other (manually defined) backends
<% if site == "pmtpa" -%>
backend test_wikipedia {
        .host = "10.0.2.193";	# srv193 for test.wikipedia.org
        .port = "80";
        .max_connections = 30;
        .connect_timeout = 3s;
        .first_byte_timeout = 10s;
        .between_bytes_timeout = 2s;
}
<% elsif site == "esams" -%>
backend bits_pmtpa {
	.host = "208.80.152.210";
	.port = "80";
        .max_connections = 100;
        .connect_timeout = 3s;
        .first_byte_timeout = 10s;
        .between_bytes_timeout = 2s;
}
<% end -%>

# Directors
<%# Expected format: { "director name" => [ "backend1", "backend2" ] } -%>
<% varnish_directors.keys.each do |director| -%>
director appservers random {
	.retries = 2;
<% varnish_directors[director].each do |backend| -%>
	{
		.backend = <%= backend.split(".")[0] %>;
		.weight = 10;
	}
<% end -%>
}
<% end -%>

# Subroutines
sub vcl_recv {
	if (req.request != "GET" && req.request != "HEAD") {
		/* We only deal with GET and HEAD by default */
		error 403 "HTTP method not allowed.";
	}

	/* Ensure we only accept Forwarded headers from the SSL proxies */
	if (client.ip ~ allow_xff) {
		// Do nothing. It seems you can't do !~ with IP matches
	} else {
		// Strip the headers, we shouldn't trust these from anything other
		// than hosts we specify. Needed for the geoiplookup code later on
		// as it will use xff. MediaWiki uses xfp.
		unset req.http.X-Forwarded-For;
		unset req.http.X-Forwarded-Proto;
	}

	/* Only accept requests for domain bits.wikimedia.org at this time */
	if (req.http.host == "bits.wikimedia.org") {
<% if site == "esams" -%>
		set req.backend = bits_pmtpa;
<% else -%>
		set req.backend = appservers;
<% end -%>
	} else if (req.http.host == "geoiplookup.wikimedia.org" ) {
		error 200 "OK";
	} else {
		error 403 "Requested target domain not allowed."; 
	}

	return (lookup);
}

sub vcl_error {
	if (req.http.host == "geoiplookup.wikimedia.org") {
		set obj.http.Content-Type = "text/javascript";

		C{
			char *ip;
			char *last;
			char date[40];
			char json[255];

			// XFF can be a comma delimited list of IPs
			char *xff_ip_str = strtok_r(VRT_GetHdr(sp, HDR_REQ, "\020X-Forwarded-For:"), ",", &last);
			if (xff_ip_str == NULL) {
				// It isn't a list; get the full header
				xff_ip_str = VRT_GetHdr(sp, HDR_REQ, "\020X-Forwarded-For:");
			}
			// Ensure the header is set
			if (xff_ip_str) {
				// Ensure XFF is a valid IP
				if (getaddrfamily(xff_ip_str) != -1) {
					// Use the XFF IP instead of the client IP
					ip = xff_ip_str;
				} else {
					ip = VRT_IP_string(sp, VRT_r_client_ip(sp));
				}
			} else {
				ip = VRT_IP_string(sp, VRT_r_client_ip(sp));
			}

			pthread_mutex_lock(&geoip_mutex);

			if (!gi) { geo_init(); }
			GeoIPRecord *record = GeoIP_record_by_addr(gi, ip);
			if (record) {
				snprintf(json, 255, "Geo = {\"city\":\"%s\",\"country\":\"%s\",\"lat\":\"%f\",\"lon\":\"%f\",\"IP\":\"%s\",\"netmask\":\"%d\"}",
					record->city,
					record->country_code,
					record->latitude,
					record->longitude,
					ip,
					GeoIP_last_netmask(gi)
				);
				pthread_mutex_unlock(&geoip_mutex);
				VRT_synth_page(sp, 0, json,  vrt_magic_string_end);
				GeoIPRecord_delete(record);
			} else {
				pthread_mutex_unlock(&geoip_mutex);
				VRT_synth_page(sp, 0, "Geo = {}",  vrt_magic_string_end);
			}
			TIM_format(TIM_real(), date);
			VRT_SetHdr(sp, HDR_OBJ, "\016Last-Modified:", date, vrt_magic_string_end);
			VRT_SetHdr(sp, HDR_OBJ, "\016Cache-Control:", "private, max-age=86400, s-maxage=0", vrt_magic_string_end);
		}C
		return (deliver);
	}

	set obj.http.Content-Type = "text/html; charset=utf-8";
	synthetic {"
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>"} obj.status " " obj.response {"</title>
  </head>
  <body>
    <h1>Error "} obj.status " " obj.response {"</h1>
    <p>"} obj.response {"</p>
    <h3>Guru Meditation:</h3>
    <p>XID: "} req.xid {"</p>
    <hr>
    <address>
       <a href="http://www.varnish-cache.org/">Varnish cache server</a>
    </address>
  </body>
</html>
"};
	return (deliver);
}

<% if site == "pmtpa" -%>
sub vcl_miss {
	# transform backend url: /<sitename>/load.php -> /w/load.php
	# set host header for backend to <sitename>
	if ( req.url ~ "^/([a-zA-Z0-9-]+\.)?([a-zA-Z0-9-]+\.)?([a-zA-Z0-9-]+)\.org/load\.php" ) {
		set bereq.http.host = regsub( req.url, "^/([^/]+)/(.*)$", "\1" );
		set bereq.url = regsub( req.url, "^/([^/]+)/load\.php(.*)?", "/w/load.php\2" );

		# Send test.wikipedia.org to the right backend server
		if ( req.url ~ "^/test\.wikipedia\.org/load\.php" ) {
			set req.backend = test_wikipedia;
		}
	}
}
<% end -%>

